desc:Auto Volume Rider
author:AI Assistant
version:1.0
changelog:Initial release

slider1:0<-24,24,0.1>Input Gain (dB)
slider2:0<0,3,1{Peak,LUFS Short,LUFS Momentary,RMS}>Mode
slider3:0.1<0,5,0.01>Lookahead (sec)
slider4:50<0.1,1000,0.1>Attack (ms)
slider5:500<1,5000,1>Release (ms)
slider6:-30<-60,0,0.1>Target Range Min (dB)
slider7:-10<-60,0,0.1>Target Range Max (dB)
slider8:0<-24,24,0.1>Output Gain (dB)
slider9:1<0,1,1{Off,On}>Limiter Enable
slider10:0<0,1,1{Peak,True Peak}>Limiter Mode

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
// Constants
PI = 3.14159265359;
LOG10 = 2.30258509299;
SQRT2 = 1.41421356237;

// Lookahead buffers
max_lookahead_samples = 5 * srate;
lookahead_buffer_L = 0;
lookahead_buffer_R = max_lookahead_samples;
write_pos = 0;

// Level measurement variables
peak_level = 0;
rms_sum_L = 0;
rms_sum_R = 0;
rms_count = 0;
rms_window = 0.1 * srate; // 100ms window for RMS

// LUFS variables
lufs_buffer_size = 0.4 * srate; // 400ms for LUFS Short
lufs_buffer_L = max_lookahead_samples * 2;
lufs_buffer_R = max_lookahead_samples * 2 + lufs_buffer_size;
lufs_write_pos = 0;
lufs_sum_L = 0;
lufs_sum_R = 0;

// Long window for LUFS Momentary (3 seconds)
lufs_long_size = 3 * srate;
lufs_long_L = max_lookahead_samples * 2 + lufs_buffer_size * 2;
lufs_long_R = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size;
lufs_long_pos = 0;
lufs_long_sum_L = 0;
lufs_long_sum_R = 0;

// Gain smoothing
current_gain = 1.0;
target_gain = 1.0;
startup_counter = 2 * srate; // 2 seconds of gentle startup

// Attack/Release parameters
attack_coeff = 0.999;
release_coeff = 0.999;

// Mode switching stability
prev_mode = 0;
mode_change_counter = 0;
mode_stability_samples = 0.5 * srate; // 500ms to stabilize

// Silence detection for reset
silence_counter = 0;
silence_threshold = 0.00000001; // Very quiet threshold
silence_samples_to_reset = 0.1 * srate; // 100ms of silence to reset

// K-weighting coefficients for LUFS (simplified version)
k_weight_a = 1.53512485958697;
k_weight_b = 2.69169618940638;

// True Peak Limiter variables
limiter_buffer_size = 64; // samples for oversampling
limiter_buffer_L = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size * 2;
limiter_buffer_R = limiter_buffer_L + limiter_buffer_size;
limiter_pos = 0;
limiter_gain = 1.0;
limiter_envelope = 0.0;
gain_reduction_display = 0.0;

// Set initial PDC (Plugin Delay Compensation)
pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = lookahead_samples;

@slider
input_gain_linear = 10^(slider1/20);
mode = slider2;
lookahead_time = slider3;
lookahead_samples = min(max_lookahead_samples, lookahead_time * srate);

// Convert Attack/Release from milliseconds to coefficients
attack_ms = slider4;
release_ms = slider5;
attack_coeff = exp(-1000 / (attack_ms * srate));
release_coeff = exp(-1000 / (release_ms * srate));

// Ensure target_range_min <= target_range_max
target_range_min = slider6;
target_range_max = slider7;

// Fix slider logic - min cannot be greater than max
target_range_min > target_range_max ? (
  target_range_min = target_range_max;
  slider6 = target_range_min;
  sliderchange(slider6);
  startup_counter = max(startup_counter, 0.5 * srate); // Reset startup on change
);

target_range_max < target_range_min ? (
  target_range_max = target_range_min;
  slider7 = target_range_max;
  sliderchange(slider7);
  startup_counter = max(startup_counter, 0.5 * srate); // Reset startup on change
);

output_gain_linear = 10^(slider8/20);
limiter_enable = slider9;
limiter_mode = slider10;

// Update PDC when lookahead changes
pdc_delay = lookahead_samples;

// Check for mode change
mode != prev_mode ? (
  mode_change_counter = mode_stability_samples;
  prev_mode = mode;
);

@sample
// Apply input gain
spl0 *= input_gain_linear;
spl1 *= input_gain_linear;

// Detect silence to reset plugin state
input_magnitude = max(abs(spl0), abs(spl1));

// Check for complete silence (playback stopped)
spl0 == 0 && spl1 == 0 ? (
  // Immediate but gentle reset for complete silence
  current_gain = current_gain * 0.99 + 1.0 * 0.01;
  target_gain = target_gain * 0.99 + 1.0 * 0.01;
  peak_level *= 0.95;
  rms_sum_L *= 0.95;
  rms_sum_R *= 0.95;
  gain_reduction_display *= 0.9;
) : input_magnitude < silence_threshold ? (
  silence_counter += 1;
  silence_counter >= silence_samples_to_reset ? (
    // Gradually reset plugin state after prolonged low-level signal
    current_gain = current_gain * 0.999 + 1.0 * 0.001; // Slowly approach unity gain
    target_gain = target_gain * 0.999 + 1.0 * 0.001;
    peak_level *= 0.99; // Decay peak level
    rms_sum_L *= 0.99; // Decay RMS
    rms_sum_R *= 0.99;
    gain_reduction_display *= 0.95; // Fade out GR display
    mode_change_counter = max(0, mode_change_counter - 1); // Reset mode transition gradually
  );
) : (
  silence_counter = 0; // Reset silence counter when signal is present
);

// Function to measure level in current mode
function measure_level(L, R, measurement_mode) (
  measurement_mode == 0 ? (
    // Peak mode
    peak_val = max(abs(L), abs(R));
    peak_val > 0 ? 20 * log(peak_val) / LOG10 : -96;
  ) : measurement_mode == 1 ? (
    // LUFS Short - simplified for display
    weighted_L = L * k_weight_a;
    weighted_R = R * k_weight_a;
    mean_square = (weighted_L * weighted_L + weighted_R * weighted_R) / 2;
    mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
  ) : measurement_mode == 2 ? (
    // LUFS Momentary - simplified for display
    weighted_L = L * k_weight_a;
    weighted_R = R * k_weight_a;
    mean_square = (weighted_L * weighted_L + weighted_R * weighted_R) / 2;
    mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
  ) : (
    // RMS mode
    rms_val = sqrt((L * L + R * R) / 2);
    rms_val > 0 ? 20 * log(rms_val) / LOG10 : -96;
  );
);

// Store input level for display using current mode
input_level_display = measure_level(spl0, spl1, mode);

// Write to lookahead buffer
lookahead_buffer_L[write_pos] = spl0;
lookahead_buffer_R[write_pos] = spl1;

// Read from lookahead buffer
read_pos = (write_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
delayed_L = lookahead_buffer_L[read_pos];
delayed_R = lookahead_buffer_R[read_pos];

write_pos = (write_pos + 1) % max_lookahead_samples;

// Measure current signal level
current_level = 0;

// Handle startup and mode switching stability  
startup_counter > 0 ? (
  startup_counter -= 1;
  // Gentle startup - keep unity gain for first 2 seconds
  target_gain = 1.0;
) : mode_change_counter > 0 ? (
  mode_change_counter -= 1;
  // Keep previous gain during stabilization
  target_gain = current_gain;
) : (
  
mode == 0 ? (
  // Peak mode - improved implementation
  peak_L = abs(spl0);
  peak_R = abs(spl1);
  instant_peak = max(peak_L, peak_R);
  // Use slower decay for peak hold
  peak_decay = exp(-1 / (0.1 * srate)); // 100ms decay
  peak_level = max(instant_peak, peak_level * peak_decay);
  current_level = peak_level > 0 ? 20 * log(peak_level) / LOG10 : -96;
) : mode == 1 ? (
  // LUFS Short (400ms)
  // K-weighting (simplified version)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  // Update buffer
  old_L = lufs_buffer_L[lufs_write_pos];
  old_R = lufs_buffer_R[lufs_write_pos];
  lufs_buffer_L[lufs_write_pos] = weighted_L * weighted_L;
  lufs_buffer_R[lufs_write_pos] = weighted_R * weighted_R;
  
  // Update sum
  lufs_sum_L = lufs_sum_L - old_L + lufs_buffer_L[lufs_write_pos];
  lufs_sum_R = lufs_sum_R - old_R + lufs_buffer_R[lufs_write_pos];
  
  lufs_write_pos = (lufs_write_pos + 1) % lufs_buffer_size;
  
  mean_square = (lufs_sum_L + lufs_sum_R) / (lufs_buffer_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : mode == 2 ? (
  // LUFS Momentary (3s)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  old_L = lufs_long_L[lufs_long_pos];
  old_R = lufs_long_R[lufs_long_pos];
  lufs_long_L[lufs_long_pos] = weighted_L * weighted_L;
  lufs_long_R[lufs_long_pos] = weighted_R * weighted_R;
  
  lufs_long_sum_L = lufs_long_sum_L - old_L + lufs_long_L[lufs_long_pos];
  lufs_long_sum_R = lufs_long_sum_R - old_R + lufs_long_R[lufs_long_pos];
  
  lufs_long_pos = (lufs_long_pos + 1) % lufs_long_size;
  
  mean_square = (lufs_long_sum_L + lufs_long_sum_R) / (lufs_long_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : (
  // RMS mode - improved implementation
  rms_coeff = exp(-1 / (0.3 * srate)); // 300ms time constant
  rms_sum_L = rms_sum_L * rms_coeff + spl0 * spl0 * (1 - rms_coeff);
  rms_sum_R = rms_sum_R * rms_coeff + spl1 * spl1 * (1 - rms_coeff);
  rms_level = sqrt((rms_sum_L + rms_sum_R) / 2);
  current_level = rms_level > 0 ? 20 * log(rms_level) / LOG10 : -96;
);

// NEW LOGIC: Target Range Window
// Calculate target level in the middle of the range window
target_center = (target_range_min + target_range_max) / 2;

// Calculate required gain to bring current level to target center
level_diff = target_center - current_level;
target_gain = 10^(level_diff/20);

// Limit gain to safe bounds to prevent clipping
target_gain = max(0.1, min(10, target_gain));

); // Close mode stabilization bracket

// Apply Attack/Release for smoothing
target_gain > current_gain ? (
  // Attack - fast reaction to level increase
  current_gain = current_gain * attack_coeff + target_gain * (1 - attack_coeff);
) : (
  // Release - slow reaction to level decrease
  current_gain = current_gain * release_coeff + target_gain * (1 - release_coeff);
);

// Apply gain to delayed signal
processed_L = delayed_L * current_gain;
processed_R = delayed_R * current_gain;

// Store processed level for display using current mode
processed_level_display = measure_level(processed_L, processed_R, mode);

// Apply output gain
processed_L *= output_gain_linear;
processed_R *= output_gain_linear;

// True Peak Limiter
reduction = 1.0;  // Default no reduction

limiter_enable ? (
  // Simple limiter implementation
  limiter_threshold = 0.99; // -0.087 dB
  
  limiter_mode == 0 ? (
    // Peak mode
    peak_val = max(abs(processed_L), abs(processed_R));
    peak_val > limiter_threshold ? (
      reduction = limiter_threshold / peak_val;
      processed_L *= reduction;
      processed_R *= reduction;
    );
  ) : (
    // True Peak mode (simplified oversampling)
    // Store in buffer for basic oversampling simulation
    limiter_buffer_L[limiter_pos] = processed_L;
    limiter_buffer_R[limiter_pos] = processed_R;
    limiter_pos = (limiter_pos + 1) % limiter_buffer_size;
    
    // Check for intersample peaks (simplified)
    interp_L = (processed_L + limiter_buffer_L[(limiter_pos - 1 + limiter_buffer_size) % limiter_buffer_size]) * 0.5;
    interp_R = (processed_R + limiter_buffer_R[(limiter_pos - 1 + limiter_buffer_size) % limiter_buffer_size]) * 0.5;
    
    true_peak = max(max(abs(processed_L), abs(processed_R)), max(abs(interp_L), abs(interp_R)));
    
    true_peak > limiter_threshold ? (
      reduction = limiter_threshold / true_peak;
      processed_L *= reduction;
      processed_R *= reduction;
    );
  );
);

// Track gain reduction for display (always, even when limiter is off)
gain_reduction_db = 20 * log(reduction) / LOG10;
// Smooth display with faster attack, slower release
reduction < 1.0 ? (
  // Attack - fast when limiting
  gain_reduction_display = min(gain_reduction_display * 0.8 + gain_reduction_db * 0.2, gain_reduction_db);
) : (
  // Release - slow decay when not limiting
  gain_reduction_display *= 0.995;
);

// Ensure gain reduction is negative (for display purposes)
gain_reduction_display = min(0, gain_reduction_display);

// Output
spl0 = processed_L;
spl1 = processed_R;

@gfx 640 480
// Clear background
gfx_clear = 0x202020;

// Vertical meters - properly centered in 640px window
// Window width = 640, center = 320
// Meter setup: Input(white) - space - Output(green) - space - GR(red)
meter_width = 20;
meter_height = 350;
meter_y = 60;

// Input meter (white) - left of center  
meter_x = 260;
// Output meter (green) - right of center
proc_meter_x = 320;
// GR meter (red) - further right
gr_meter_x = 360;
gr_meter_width = 10;

// Levels are already in dB from measure_level function
input_level_db = input_level_display;
processed_level_db = processed_level_display;

// Input Level Meter (White)
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(meter_x, meter_y, meter_width, meter_height, 0); // Frame

// Fill based on level (-60dB to 0dB range, with expanded scale for 0 to -20)
// 0 dB at top, -60 dB at bottom
function db_to_pixel(db_val) (
  db_val >= -20 ? (
    // Expanded scale for 0 to -20 dB (top 60% of meter)
    pixel_pos = ((-db_val) / 20) * (meter_height * 0.6);
  ) : (
    // Compressed scale for -20 to -60 dB (bottom 40% of meter)
    pixel_pos = meter_height * 0.6 + ((-db_val - 20) / 40) * (meter_height * 0.4);
  );
  max(0, min(meter_height, pixel_pos));
);

input_fill_height = db_to_pixel(input_level_db);
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(meter_x + 1, meter_y + 1, meter_width - 2, input_fill_height);

// Label
gfx_x = meter_x + 5; gfx_y = meter_y + meter_height + 10;
gfx_printf("In");

// Processed Level Meter (Green)
gfx_r = 0; gfx_g = 1; gfx_b = 0;
gfx_rect(proc_meter_x, meter_y, meter_width, meter_height, 0); // Frame

// Fill based on level
processed_fill_height = db_to_pixel(processed_level_db);
gfx_r = 0; gfx_g = 1; gfx_b = 0;
gfx_rect(proc_meter_x + 1, meter_y + 1, meter_width - 2, processed_fill_height);

// Label
gfx_x = proc_meter_x + 2; gfx_y = meter_y + meter_height + 10;
gfx_printf("Out");

// Gain Reduction Meter (Red, thin)
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_rect(gr_meter_x, meter_y, gr_meter_width, meter_height, 0); // Frame

// Fill based on gain reduction (0 to -20 dB, from top down)
gr_fill_height = ((-gain_reduction_display) / 20) * meter_height;
gr_fill_height = max(0, min(meter_height, gr_fill_height));
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_rect(gr_meter_x + 1, meter_y + 1, gr_meter_width - 2, gr_fill_height);

// Label
gfx_x = gr_meter_x + 1; gfx_y = meter_y + meter_height + 10;
gfx_printf("GR");

// Target Range markers on both meters
target_min_pos = meter_y + db_to_pixel(target_range_min);
target_max_pos = meter_y + db_to_pixel(target_range_max);

// Target range markers (Yellow)
gfx_r = 1; gfx_g = 1; gfx_b = 0;
gfx_line(meter_x - 10, target_min_pos, gr_meter_x + gr_meter_width + 5, target_min_pos);
gfx_line(meter_x - 10, target_max_pos, gr_meter_x + gr_meter_width + 5, target_max_pos);

// Target center line (Red)
target_center_pos = meter_y + db_to_pixel(target_center);
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_line(meter_x - 10, target_center_pos, gr_meter_x + gr_meter_width + 5, target_center_pos);

// dB Scale
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
// Draw scale marks manually with expanded scale
scale_pos = meter_y + db_to_pixel(0);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("0");

scale_pos = meter_y + db_to_pixel(-3);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-3");

scale_pos = meter_y + db_to_pixel(-6);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-6");

scale_pos = meter_y + db_to_pixel(-10);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-10");

scale_pos = meter_y + db_to_pixel(-15);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-15");

scale_pos = meter_y + db_to_pixel(-20);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-20");

scale_pos = meter_y + db_to_pixel(-40);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-40");

scale_pos = meter_y + db_to_pixel(-60);
gfx_line(meter_x - 25, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 45; gfx_y = scale_pos - 5;
gfx_printf("-60");

// Clean interface without numerical readouts