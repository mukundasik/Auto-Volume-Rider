desc:Auto Volume Rider
author:AI Assistant
version:1.0
changelog:Initial release

slider1:0<-24,24,0.1>Input Gain (dB)
slider2:0<0,3,1{Peak,LUFS Short,LUFS Momentary,RMS}>Mode
slider3:-30<-60,0,0.1>Range Minimum (dB)
slider4:-6<-60,0,0.1>Range Maximum (dB)
slider5:-18<-60,0,0.1>Target Output Volume (dB)
slider6:0.1<0,5,0.01>Lookahead (sec)
slider7:10<0.1,1000,0.1>Attack (ms)
slider8:100<1,5000,1>Release (ms)

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
// Constants
PI = 3.14159265359;
LOG10 = 2.30258509299;
SQRT2 = 1.41421356237;

// Lookahead buffers
max_lookahead_samples = 5 * srate;
lookahead_buffer_L = 0;
lookahead_buffer_R = max_lookahead_samples;
write_pos = 0;

// Level measurement variables
peak_level = 0;
rms_sum_L = 0;
rms_sum_R = 0;
rms_count = 0;
rms_window = 0.1 * srate; // 100ms window for RMS

// LUFS variables
lufs_buffer_size = 0.4 * srate; // 400ms for LUFS Short
lufs_buffer_L = max_lookahead_samples * 2;
lufs_buffer_R = max_lookahead_samples * 2 + lufs_buffer_size;
lufs_write_pos = 0;
lufs_sum_L = 0;
lufs_sum_R = 0;

// Long window for LUFS Momentary (3 seconds)
lufs_long_size = 3 * srate;
lufs_long_L = max_lookahead_samples * 2 + lufs_buffer_size * 2;
lufs_long_R = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size;
lufs_long_pos = 0;
lufs_long_sum_L = 0;
lufs_long_sum_R = 0;

// Gain smoothing
current_gain = 1.0;
target_gain = 1.0;

// Attack/Release parameters
attack_coeff = 0.999;
release_coeff = 0.999;

// K-weighting coefficients for LUFS (simplified version)
k_weight_a = 1.53512485958697;
k_weight_b = 2.69169618940638;

@slider
input_gain_linear = 10^(slider1/20);
mode = slider2;
range_min = slider3;
range_max = slider4;
target_output = slider5;
lookahead_time = slider6;
lookahead_samples = min(max_lookahead_samples, lookahead_time * srate);

// Convert Attack/Release from milliseconds to coefficients
attack_ms = slider7;
release_ms = slider8;
attack_coeff = exp(-1000 / (attack_ms * srate));
release_coeff = exp(-1000 / (release_ms * srate));

@sample
// Apply input gain
spl0 *= input_gain_linear;
spl1 *= input_gain_linear;

// Write to lookahead buffer
lookahead_buffer_L[write_pos] = spl0;
lookahead_buffer_R[write_pos] = spl1;

// Read from lookahead buffer
read_pos = (write_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
delayed_L = lookahead_buffer_L[read_pos];
delayed_R = lookahead_buffer_R[read_pos];

write_pos = (write_pos + 1) % max_lookahead_samples;

// Measure current signal level
current_level = 0;

mode == 0 ? (
  // Peak mode
  peak_L = abs(spl0);
  peak_R = abs(spl1);
  peak_level = max(peak_L, peak_R);
  peak_level = max(peak_level * 0.999, max(peak_L, peak_R));
  current_level = peak_level > 0 ? 20 * log(peak_level) / LOG10 : -96;
) : mode == 1 ? (
  // LUFS Short (400ms)
  // K-weighting (simplified version)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  // Update buffer
  old_L = lufs_buffer_L[lufs_write_pos];
  old_R = lufs_buffer_R[lufs_write_pos];
  lufs_buffer_L[lufs_write_pos] = weighted_L * weighted_L;
  lufs_buffer_R[lufs_write_pos] = weighted_R * weighted_R;
  
  // Update sum
  lufs_sum_L = lufs_sum_L - old_L + lufs_buffer_L[lufs_write_pos];
  lufs_sum_R = lufs_sum_R - old_R + lufs_buffer_R[lufs_write_pos];
  
  lufs_write_pos = (lufs_write_pos + 1) % lufs_buffer_size;
  
  mean_square = (lufs_sum_L + lufs_sum_R) / (lufs_buffer_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : mode == 2 ? (
  // LUFS Momentary (3s)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  old_L = lufs_long_L[lufs_long_pos];
  old_R = lufs_long_R[lufs_long_pos];
  lufs_long_L[lufs_long_pos] = weighted_L * weighted_L;
  lufs_long_R[lufs_long_pos] = weighted_R * weighted_R;
  
  lufs_long_sum_L = lufs_long_sum_L - old_L + lufs_long_L[lufs_long_pos];
  lufs_long_sum_R = lufs_long_sum_R - old_R + lufs_long_R[lufs_long_pos];
  
  lufs_long_pos = (lufs_long_pos + 1) % lufs_long_size;
  
  mean_square = (lufs_long_sum_L + lufs_long_sum_R) / (lufs_long_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : (
  // RMS mode
  rms_sum_L = rms_sum_L * 0.999 + spl0 * spl0;
  rms_sum_R = rms_sum_R * 0.999 + spl1 * spl1;
  rms_level = sqrt((rms_sum_L + rms_sum_R) / 2);
  current_level = rms_level > 0 ? 20 * log(rms_level) / LOG10 : -96;
);

// Apply Range Minimum/Maximum as input signal boundaries
processed_level = current_level;

// If signal is quieter than Range Minimum - boost to Range Minimum
processed_level < range_min ? (
  processed_level = range_min;
);

// If signal is louder than Range Maximum - reduce to Range Maximum  
processed_level > range_max ? (
  processed_level = range_max;
);

// Now adjust to Target Output Volume
level_diff = target_output - processed_level;
target_gain = 10^(level_diff/20);

// Limit gain to reasonable bounds
target_gain = max(0.01, min(100, target_gain));

// Apply Attack/Release for smoothing
target_gain > current_gain ? (
  // Attack - fast reaction to level increase
  current_gain = current_gain * attack_coeff + target_gain * (1 - attack_coeff);
) : (
  // Release - slow reaction to level decrease
  current_gain = current_gain * release_coeff + target_gain * (1 - release_coeff);
);

// Apply gain to delayed signal
spl0 = delayed_L * current_gain;
spl1 = delayed_R * current_gain;

@gfx 640 480
// Simple graphical interface
gfx_clear = 0x000000;

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 10;
gfx_printf("Auto Volume Rider");

gfx_x = 10; gfx_y = 40;
gfx_printf("Input Level: %.1f dB", current_level);

gfx_x = 10; gfx_y = 60;
gfx_printf("Processed Level: %.1f dB", processed_level);

gfx_x = 10; gfx_y = 80;
gfx_printf("Current Gain: %.2f (%.1f dB)", current_gain, 20 * log(current_gain) / LOG10);

gfx_x = 10; gfx_y = 100;
gfx_printf("Target: %.1f dB", target_output);

gfx_x = 10; gfx_y = 120;
gfx_printf("Range: %.1f to %.1f dB", range_min, range_max);

// Labels for indicators
gfx_x = 10; gfx_y = 135;
gfx_printf("Input Level:");
gfx_x = 10; gfx_y = 155;
gfx_printf("Processed Level:");

// Input level indicator
gfx_r = 0; gfx_g = 1; gfx_b = 0;
level_bar_width = (current_level + 60) / 60 * 200;
level_bar_width = max(0, min(200, level_bar_width));
gfx_rect(10, 150, level_bar_width, 15);

// Processed level indicator
gfx_r = 0; gfx_g = 0.8; gfx_b = 1;
processed_bar_width = (processed_level + 60) / 60 * 200;
processed_bar_width = max(0, min(200, processed_bar_width));
gfx_rect(10, 170, processed_bar_width, 15);

// Indicator frames
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(10, 150, 200, 15, 0);
gfx_rect(10, 170, 200, 15, 0);

// Target mark
target_pos = (target_output + 60) / 60 * 200;
target_pos = max(0, min(200, target_pos));
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_line(10 + target_pos, 145, 10 + target_pos, 190);

// Range Min/Max marks
range_min_pos = (range_min + 60) / 60 * 200;
range_max_pos = (range_max + 60) / 60 * 200;
range_min_pos = max(0, min(200, range_min_pos));
range_max_pos = max(0, min(200, range_max_pos));
gfx_r = 1; gfx_g = 1; gfx_b = 0;
gfx_line(10 + range_min_pos, 145, 10 + range_min_pos, 190);
gfx_line(10 + range_max_pos, 145, 10 + range_max_pos, 190);