desc:Auto Volume Rider
author:AI Assistant
version:1.0
changelog:Initial release

slider1:0<-24,24,0.1>Input Gain (dB)
slider2:0<0,3,1{Peak,LUFS Short,LUFS Momentary,RMS}>Mode
slider3:-25<-60,0,0.1>Target Range Min (dB)
slider4:-6<-60,0,0.1>Target Range Max (dB)
slider5:0.1<0,5,0.01>Lookahead (sec)
slider6:10<0.1,1000,0.1>Attack (ms)
slider7:100<1,5000,1>Release (ms)
slider8:0<-24,24,0.1>Output Gain (dB)
slider9:1<0,1,1{Off,On}>Limiter Enable
slider10:0<0,1,1{Peak,True Peak}>Limiter Mode

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
// Constants
PI = 3.14159265359;
LOG10 = 2.30258509299;
SQRT2 = 1.41421356237;

// Lookahead buffers
max_lookahead_samples = 5 * srate;
lookahead_buffer_L = 0;
lookahead_buffer_R = max_lookahead_samples;
write_pos = 0;

// Level measurement variables
peak_level = 0;
rms_sum_L = 0;
rms_sum_R = 0;
rms_count = 0;
rms_window = 0.1 * srate; // 100ms window for RMS

// LUFS variables
lufs_buffer_size = 0.4 * srate; // 400ms for LUFS Short
lufs_buffer_L = max_lookahead_samples * 2;
lufs_buffer_R = max_lookahead_samples * 2 + lufs_buffer_size;
lufs_write_pos = 0;
lufs_sum_L = 0;
lufs_sum_R = 0;

// Long window for LUFS Momentary (3 seconds)
lufs_long_size = 3 * srate;
lufs_long_L = max_lookahead_samples * 2 + lufs_buffer_size * 2;
lufs_long_R = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size;
lufs_long_pos = 0;
lufs_long_sum_L = 0;
lufs_long_sum_R = 0;

// Gain smoothing
current_gain = 1.0;
target_gain = 1.0;

// Attack/Release parameters
attack_coeff = 0.999;
release_coeff = 0.999;

// Mode switching stability
prev_mode = 0;
mode_change_counter = 0;
mode_stability_samples = 0.5 * srate; // 500ms to stabilize

// K-weighting coefficients for LUFS (simplified version)
k_weight_a = 1.53512485958697;
k_weight_b = 2.69169618940638;

// True Peak Limiter variables
limiter_buffer_size = 64; // samples for oversampling
limiter_buffer_L = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size * 2;
limiter_buffer_R = limiter_buffer_L + limiter_buffer_size;
limiter_pos = 0;
limiter_gain = 1.0;
limiter_envelope = 0.0;
gain_reduction_display = 0.0;

// Set initial PDC (Plugin Delay Compensation)
pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = lookahead_samples;

@slider
input_gain_linear = 10^(slider1/20);
mode = slider2;

// Ensure target_range_min <= target_range_max
target_range_min = slider3;
target_range_max = slider4;

// Fix slider logic - min cannot be greater than max
target_range_min > target_range_max ? (
  target_range_min = target_range_max;
  slider3 = target_range_min;
  sliderchange(slider3);
);

target_range_max < target_range_min ? (
  target_range_max = target_range_min;
  slider4 = target_range_max;
  sliderchange(slider4);
);

lookahead_time = slider5;
lookahead_samples = min(max_lookahead_samples, lookahead_time * srate);
output_gain_linear = 10^(slider8/20);
limiter_enable = slider9;
limiter_mode = slider10;

// Update PDC when lookahead changes
pdc_delay = lookahead_samples;

// Check for mode change
mode != prev_mode ? (
  mode_change_counter = mode_stability_samples;
  prev_mode = mode;
);

// Convert Attack/Release from milliseconds to coefficients
attack_ms = slider6;
release_ms = slider7;
attack_coeff = exp(-1000 / (attack_ms * srate));
release_coeff = exp(-1000 / (release_ms * srate));

@sample
// Apply input gain
spl0 *= input_gain_linear;
spl1 *= input_gain_linear;

// Function to measure level in current mode
function measure_level(L, R, measurement_mode) (
  measurement_mode == 0 ? (
    // Peak mode
    peak_val = max(abs(L), abs(R));
    peak_val > 0 ? 20 * log(peak_val) / LOG10 : -96;
  ) : measurement_mode == 1 ? (
    // LUFS Short - simplified for display
    weighted_L = L * k_weight_a;
    weighted_R = R * k_weight_a;
    mean_square = (weighted_L * weighted_L + weighted_R * weighted_R) / 2;
    mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
  ) : measurement_mode == 2 ? (
    // LUFS Momentary - simplified for display
    weighted_L = L * k_weight_a;
    weighted_R = R * k_weight_a;
    mean_square = (weighted_L * weighted_L + weighted_R * weighted_R) / 2;
    mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
  ) : (
    // RMS mode
    rms_val = sqrt((L * L + R * R) / 2);
    rms_val > 0 ? 20 * log(rms_val) / LOG10 : -96;
  );
);

// Store input level for display using current mode
input_level_display = measure_level(spl0, spl1, mode);

// Write to lookahead buffer
lookahead_buffer_L[write_pos] = spl0;
lookahead_buffer_R[write_pos] = spl1;

// Read from lookahead buffer
read_pos = (write_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
delayed_L = lookahead_buffer_L[read_pos];
delayed_R = lookahead_buffer_R[read_pos];

write_pos = (write_pos + 1) % max_lookahead_samples;

// Measure current signal level
current_level = 0;

// Handle mode switching stability
mode_change_counter > 0 ? (
  mode_change_counter -= 1;
  // Keep previous gain during stabilization
  target_gain = current_gain;
) : (
  
mode == 0 ? (
  // Peak mode - improved implementation
  peak_L = abs(spl0);
  peak_R = abs(spl1);
  instant_peak = max(peak_L, peak_R);
  // Use slower decay for peak hold
  peak_decay = exp(-1 / (0.1 * srate)); // 100ms decay
  peak_level = max(instant_peak, peak_level * peak_decay);
  current_level = peak_level > 0 ? 20 * log(peak_level) / LOG10 : -96;
) : mode == 1 ? (
  // LUFS Short (400ms)
  // K-weighting (simplified version)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  // Update buffer
  old_L = lufs_buffer_L[lufs_write_pos];
  old_R = lufs_buffer_R[lufs_write_pos];
  lufs_buffer_L[lufs_write_pos] = weighted_L * weighted_L;
  lufs_buffer_R[lufs_write_pos] = weighted_R * weighted_R;
  
  // Update sum
  lufs_sum_L = lufs_sum_L - old_L + lufs_buffer_L[lufs_write_pos];
  lufs_sum_R = lufs_sum_R - old_R + lufs_buffer_R[lufs_write_pos];
  
  lufs_write_pos = (lufs_write_pos + 1) % lufs_buffer_size;
  
  mean_square = (lufs_sum_L + lufs_sum_R) / (lufs_buffer_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : mode == 2 ? (
  // LUFS Momentary (3s)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  old_L = lufs_long_L[lufs_long_pos];
  old_R = lufs_long_R[lufs_long_pos];
  lufs_long_L[lufs_long_pos] = weighted_L * weighted_L;
  lufs_long_R[lufs_long_pos] = weighted_R * weighted_R;
  
  lufs_long_sum_L = lufs_long_sum_L - old_L + lufs_long_L[lufs_long_pos];
  lufs_long_sum_R = lufs_long_sum_R - old_R + lufs_long_R[lufs_long_pos];
  
  lufs_long_pos = (lufs_long_pos + 1) % lufs_long_size;
  
  mean_square = (lufs_long_sum_L + lufs_long_sum_R) / (lufs_long_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : (
  // RMS mode - improved implementation
  rms_coeff = exp(-1 / (0.3 * srate)); // 300ms time constant
  rms_sum_L = rms_sum_L * rms_coeff + spl0 * spl0 * (1 - rms_coeff);
  rms_sum_R = rms_sum_R * rms_coeff + spl1 * spl1 * (1 - rms_coeff);
  rms_level = sqrt((rms_sum_L + rms_sum_R) / 2);
  current_level = rms_level > 0 ? 20 * log(rms_level) / LOG10 : -96;
);

// NEW LOGIC: Target Range Window
// Calculate target level in the middle of the range window
target_center = (target_range_min + target_range_max) / 2;

// Calculate required gain to bring current level to target center
level_diff = target_center - current_level;
target_gain = 10^(level_diff/20);

// Limit gain to reasonable bounds
target_gain = max(0.01, min(100, target_gain));

); // Close mode stabilization bracket

// Apply Attack/Release for smoothing
target_gain > current_gain ? (
  // Attack - fast reaction to level increase
  current_gain = current_gain * attack_coeff + target_gain * (1 - attack_coeff);
) : (
  // Release - slow reaction to level decrease
  current_gain = current_gain * release_coeff + target_gain * (1 - release_coeff);
);

// Apply gain to delayed signal
processed_L = delayed_L * current_gain;
processed_R = delayed_R * current_gain;

// Store processed level for display using current mode
processed_level_display = measure_level(processed_L, processed_R, mode);

// Apply output gain
processed_L *= output_gain_linear;
processed_R *= output_gain_linear;

// True Peak Limiter
limiter_enable ? (
  // Simple limiter implementation
  limiter_threshold = 0.99; // -0.087 dB
  reduction = 1.0;
  
  limiter_mode == 0 ? (
    // Peak mode
    peak_val = max(abs(processed_L), abs(processed_R));
    peak_val > limiter_threshold ? (
      reduction = limiter_threshold / peak_val;
      processed_L *= reduction;
      processed_R *= reduction;
    );
  ) : (
    // True Peak mode (simplified oversampling)
    // Store in buffer for basic oversampling simulation
    limiter_buffer_L[limiter_pos] = processed_L;
    limiter_buffer_R[limiter_pos] = processed_R;
    limiter_pos = (limiter_pos + 1) % limiter_buffer_size;
    
    // Check for intersample peaks (simplified)
    interp_L = (processed_L + limiter_buffer_L[(limiter_pos - 1 + limiter_buffer_size) % limiter_buffer_size]) * 0.5;
    interp_R = (processed_R + limiter_buffer_R[(limiter_pos - 1 + limiter_buffer_size) % limiter_buffer_size]) * 0.5;
    
    true_peak = max(max(abs(processed_L), abs(processed_R)), max(abs(interp_L), abs(interp_R)));
    
    true_peak > limiter_threshold ? (
      reduction = limiter_threshold / true_peak;
      processed_L *= reduction;
      processed_R *= reduction;
    );
  );
  
  // Track gain reduction for display
  gain_reduction_db = 20 * log(reduction) / LOG10;
  gain_reduction_display = max(gain_reduction_display * 0.95, gain_reduction_db);
) : (
  gain_reduction_display *= 0.95; // Decay when limiter is off
);

// Output
spl0 = processed_L;
spl1 = processed_R;

@gfx 640 480
// Clear background
gfx_clear = 0x202020;

// Minimal status info
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 20;
gfx_printf("Target Range: %.1f to %.1f dB", target_range_min, target_range_max);

// Vertical meters - positioned in center
meter_x = 300;
meter_width = 20;
meter_height = 350;
meter_y = 60;

// Levels are already in dB from measure_level function
input_level_db = input_level_display;
processed_level_db = processed_level_display;

// Input Level Meter (White)
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(meter_x, meter_y, meter_width, meter_height, 0); // Frame

// Fill based on level (-60dB to 0dB range, with expanded scale for 0 to -20)
function db_to_pixel(db_val) (
  db_val >= -20 ? (
    // Expanded scale for 0 to -20 dB (top 60% of meter)
    pixel_pos = ((-db_val) / 20) * (meter_height * 0.6);
  ) : (
    // Compressed scale for -20 to -60 dB (bottom 40% of meter)
    pixel_pos = meter_height * 0.6 + ((-db_val - 20) / 40) * (meter_height * 0.4);
  );
  max(0, min(meter_height, pixel_pos));
);

input_fill_height = db_to_pixel(input_level_db);
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(meter_x + 1, meter_y + meter_height - input_fill_height, meter_width - 2, input_fill_height);

// Label
gfx_x = meter_x - 5; gfx_y = meter_y + meter_height + 10;
gfx_printf("In");

// Processed Level Meter (Green)
proc_meter_x = meter_x + 40;
gfx_r = 0; gfx_g = 1; gfx_b = 0;
gfx_rect(proc_meter_x, meter_y, meter_width, meter_height, 0); // Frame

// Fill based on level
processed_fill_height = db_to_pixel(processed_level_db);
gfx_r = 0; gfx_g = 1; gfx_b = 0;
gfx_rect(proc_meter_x + 1, meter_y + meter_height - processed_fill_height, meter_width - 2, processed_fill_height);

// Label
gfx_x = proc_meter_x - 5; gfx_y = meter_y + meter_height + 10;
gfx_printf("Out");

// Gain Reduction Meter (Red, thin)
gr_meter_x = proc_meter_x + 40;
gr_meter_width = 8;
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_rect(gr_meter_x, meter_y, gr_meter_width, meter_height, 0); // Frame

// Fill based on gain reduction (0 to -20 dB)
gr_fill_height = ((-gain_reduction_display) / 20) * meter_height;
gr_fill_height = max(0, min(meter_height, gr_fill_height));
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_rect(gr_meter_x + 1, meter_y + 1, gr_meter_width - 2, gr_fill_height);

// Label
gfx_x = gr_meter_x - 5; gfx_y = meter_y + meter_height + 10;
gfx_printf("GR");

// Target Range markers on both meters
target_min_pos = meter_y + meter_height - db_to_pixel(target_range_min);
target_max_pos = meter_y + meter_height - db_to_pixel(target_range_max);

// Target range markers (Yellow)
gfx_r = 1; gfx_g = 1; gfx_b = 0;
gfx_line(meter_x - 5, target_min_pos, proc_meter_x + meter_width + 5, target_min_pos);
gfx_line(meter_x - 5, target_max_pos, proc_meter_x + meter_width + 5, target_max_pos);

// Target center line (Red)
target_center_pos = meter_y + meter_height - db_to_pixel(target_center);
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_line(meter_x - 5, target_center_pos, proc_meter_x + meter_width + 5, target_center_pos);

// dB Scale
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
// Draw scale marks manually with expanded scale
scale_pos = meter_y + meter_height - db_to_pixel(0);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("0");

scale_pos = meter_y + meter_height - db_to_pixel(-3);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-3");

scale_pos = meter_y + meter_height - db_to_pixel(-6);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-6");

scale_pos = meter_y + meter_height - db_to_pixel(-10);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-10");

scale_pos = meter_y + meter_height - db_to_pixel(-15);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-15");

scale_pos = meter_y + meter_height - db_to_pixel(-20);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-20");

scale_pos = meter_y + meter_height - db_to_pixel(-40);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-40");

scale_pos = meter_y + meter_height - db_to_pixel(-60);
gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
gfx_printf("-60");

// Clean interface without numerical readouts