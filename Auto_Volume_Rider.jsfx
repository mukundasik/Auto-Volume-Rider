desc:Auto Volume Rider
author:AI Assistant
version:1.0
changelog:Initial release

slider1:0<-24,24,0.1>Input Gain (dB)
slider2:0<0,3,1{Peak,LUFS Short,LUFS Momentary,RMS}>Mode
slider3:-30<-60,0,0.1>Target Range Min (dB)
slider4:-18<-60,0,0.1>Target Range Max (dB)
slider5:0.1<0,5,0.01>Lookahead (sec)
slider6:10<0.1,1000,0.1>Attack (ms)
slider7:100<1,5000,1>Release (ms)
slider8:0<-24,24,0.1>Output Gain (dB)
slider9:1<0,1,1{Off,On}>Limiter Enable
slider10:0<0,1,1{Peak,True Peak}>Limiter Mode

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
// Constants
PI = 3.14159265359;
LOG10 = 2.30258509299;
SQRT2 = 1.41421356237;

// Lookahead buffers
max_lookahead_samples = 5 * srate;
lookahead_buffer_L = 0;
lookahead_buffer_R = max_lookahead_samples;
write_pos = 0;

// Level measurement variables
peak_level = 0;
rms_sum_L = 0;
rms_sum_R = 0;
rms_count = 0;
rms_window = 0.1 * srate; // 100ms window for RMS

// LUFS variables
lufs_buffer_size = 0.4 * srate; // 400ms for LUFS Short
lufs_buffer_L = max_lookahead_samples * 2;
lufs_buffer_R = max_lookahead_samples * 2 + lufs_buffer_size;
lufs_write_pos = 0;
lufs_sum_L = 0;
lufs_sum_R = 0;

// Long window for LUFS Momentary (3 seconds)
lufs_long_size = 3 * srate;
lufs_long_L = max_lookahead_samples * 2 + lufs_buffer_size * 2;
lufs_long_R = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size;
lufs_long_pos = 0;
lufs_long_sum_L = 0;
lufs_long_sum_R = 0;

// Gain smoothing
current_gain = 1.0;
target_gain = 1.0;

// Attack/Release parameters
attack_coeff = 0.999;
release_coeff = 0.999;

// K-weighting coefficients for LUFS (simplified version)
k_weight_a = 1.53512485958697;
k_weight_b = 2.69169618940638;

// True Peak Limiter variables
limiter_buffer_size = 64; // samples for oversampling
limiter_buffer_L = max_lookahead_samples * 2 + lufs_buffer_size * 2 + lufs_long_size * 2;
limiter_buffer_R = limiter_buffer_L + limiter_buffer_size;
limiter_pos = 0;
limiter_gain = 1.0;
limiter_envelope = 0.0;

@slider
input_gain_linear = 10^(slider1/20);
mode = slider2;
target_range_min = slider3;
target_range_max = slider4;
lookahead_time = slider5;
lookahead_samples = min(max_lookahead_samples, lookahead_time * srate);
output_gain_linear = 10^(slider8/20);
limiter_enable = slider9;
limiter_mode = slider10;

// Convert Attack/Release from milliseconds to coefficients
attack_ms = slider6;
release_ms = slider7;
attack_coeff = exp(-1000 / (attack_ms * srate));
release_coeff = exp(-1000 / (release_ms * srate));

@sample
// Apply input gain
spl0 *= input_gain_linear;
spl1 *= input_gain_linear;

// Store input level for display
input_level_display = max(abs(spl0), abs(spl1));

// Write to lookahead buffer
lookahead_buffer_L[write_pos] = spl0;
lookahead_buffer_R[write_pos] = spl1;

// Read from lookahead buffer
read_pos = (write_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
delayed_L = lookahead_buffer_L[read_pos];
delayed_R = lookahead_buffer_R[read_pos];

write_pos = (write_pos + 1) % max_lookahead_samples;

// Measure current signal level
current_level = 0;

mode == 0 ? (
  // Peak mode
  peak_L = abs(spl0);
  peak_R = abs(spl1);
  peak_level = max(peak_L, peak_R);
  peak_level = max(peak_level * 0.999, max(peak_L, peak_R));
  current_level = peak_level > 0 ? 20 * log(peak_level) / LOG10 : -96;
) : mode == 1 ? (
  // LUFS Short (400ms)
  // K-weighting (simplified version)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  // Update buffer
  old_L = lufs_buffer_L[lufs_write_pos];
  old_R = lufs_buffer_R[lufs_write_pos];
  lufs_buffer_L[lufs_write_pos] = weighted_L * weighted_L;
  lufs_buffer_R[lufs_write_pos] = weighted_R * weighted_R;
  
  // Update sum
  lufs_sum_L = lufs_sum_L - old_L + lufs_buffer_L[lufs_write_pos];
  lufs_sum_R = lufs_sum_R - old_R + lufs_buffer_R[lufs_write_pos];
  
  lufs_write_pos = (lufs_write_pos + 1) % lufs_buffer_size;
  
  mean_square = (lufs_sum_L + lufs_sum_R) / (lufs_buffer_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : mode == 2 ? (
  // LUFS Momentary (3s)
  weighted_L = spl0 * k_weight_a;
  weighted_R = spl1 * k_weight_a;
  
  old_L = lufs_long_L[lufs_long_pos];
  old_R = lufs_long_R[lufs_long_pos];
  lufs_long_L[lufs_long_pos] = weighted_L * weighted_L;
  lufs_long_R[lufs_long_pos] = weighted_R * weighted_R;
  
  lufs_long_sum_L = lufs_long_sum_L - old_L + lufs_long_L[lufs_long_pos];
  lufs_long_sum_R = lufs_long_sum_R - old_R + lufs_long_R[lufs_long_pos];
  
  lufs_long_pos = (lufs_long_pos + 1) % lufs_long_size;
  
  mean_square = (lufs_long_sum_L + lufs_long_sum_R) / (lufs_long_size * 2);
  current_level = mean_square > 0 ? -0.691 + 10 * log(mean_square) / LOG10 : -96;
) : (
  // RMS mode
  rms_sum_L = rms_sum_L * 0.999 + spl0 * spl0;
  rms_sum_R = rms_sum_R * 0.999 + spl1 * spl1;
  rms_level = sqrt((rms_sum_L + rms_sum_R) / 2);
  current_level = rms_level > 0 ? 20 * log(rms_level) / LOG10 : -96;
);

// NEW LOGIC: Target Range Window
// Calculate target level in the middle of the range window
target_center = (target_range_min + target_range_max) / 2;

// Calculate required gain to bring current level to target center
level_diff = target_center - current_level;
target_gain = 10^(level_diff/20);

// Limit gain to reasonable bounds
target_gain = max(0.01, min(100, target_gain));

// Apply Attack/Release for smoothing
target_gain > current_gain ? (
  // Attack - fast reaction to level increase
  current_gain = current_gain * attack_coeff + target_gain * (1 - attack_coeff);
) : (
  // Release - slow reaction to level decrease
  current_gain = current_gain * release_coeff + target_gain * (1 - release_coeff);
);

// Apply gain to delayed signal
processed_L = delayed_L * current_gain;
processed_R = delayed_R * current_gain;

// Store processed level for display
processed_level_display = max(abs(processed_L), abs(processed_R));

// Apply output gain
processed_L *= output_gain_linear;
processed_R *= output_gain_linear;

// True Peak Limiter
limiter_enable ? (
  // Simple limiter implementation
  limiter_threshold = 0.99; // -0.087 dB
  
  limiter_mode == 0 ? (
    // Peak mode
    peak_val = max(abs(processed_L), abs(processed_R));
    peak_val > limiter_threshold ? (
      reduction = limiter_threshold / peak_val;
      processed_L *= reduction;
      processed_R *= reduction;
    );
  ) : (
    // True Peak mode (simplified oversampling)
    // Store in buffer for basic oversampling simulation
    limiter_buffer_L[limiter_pos] = processed_L;
    limiter_buffer_R[limiter_pos] = processed_R;
    limiter_pos = (limiter_pos + 1) % limiter_buffer_size;
    
    // Check for intersample peaks (simplified)
    interp_L = (processed_L + limiter_buffer_L[(limiter_pos - 1 + limiter_buffer_size) % limiter_buffer_size]) * 0.5;
    interp_R = (processed_R + limiter_buffer_R[(limiter_pos - 1 + limiter_buffer_size) % limiter_buffer_size]) * 0.5;
    
    true_peak = max(max(abs(processed_L), abs(processed_R)), max(abs(interp_L), abs(interp_R)));
    
    true_peak > limiter_threshold ? (
      reduction = limiter_threshold / true_peak;
      processed_L *= reduction;
      processed_R *= reduction;
    );
  );
);

// Output
spl0 = processed_L;
spl1 = processed_R;

@gfx 640 480
// Clear background
gfx_clear = 0x202020;

// Title
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 10;
gfx_printf("Auto Volume Rider");

// Status info
gfx_x = 10; gfx_y = 30;
gfx_printf("Mode: %s", mode == 0 ? "Peak" : mode == 1 ? "LUFS Short" : mode == 2 ? "LUFS Momentary" : "RMS");

gfx_x = 10; gfx_y = 50;
gfx_printf("Target Range: %.1f to %.1f dB", target_range_min, target_range_max);

gfx_x = 10; gfx_y = 70;
gfx_printf("Current Gain: %.2f (%.1f dB)", current_gain, 20 * log(current_gain) / LOG10);

gfx_x = 10; gfx_y = 90;
gfx_printf("Limiter: %s (%s)", limiter_enable ? "ON" : "OFF", limiter_mode ? "True Peak" : "Peak");

// Vertical meters - positioned in center
meter_x = 280;
meter_width = 20;
meter_height = 300;
meter_y = 120;

// Convert levels to display values
input_level_db = input_level_display > 0 ? 20 * log(input_level_display) / LOG10 : -96;
processed_level_db = processed_level_display > 0 ? 20 * log(processed_level_display) / LOG10 : -96;

// Input Level Meter (White)
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(meter_x, meter_y, meter_width, meter_height, 0); // Frame

// Fill based on level (-60dB to 0dB range)
input_fill_height = ((input_level_db + 60) / 60) * meter_height;
input_fill_height = max(0, min(meter_height, input_fill_height));
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_rect(meter_x + 1, meter_y + meter_height - input_fill_height, meter_width - 2, input_fill_height);

// Label
gfx_x = meter_x - 10; gfx_y = meter_y + meter_height + 10;
gfx_printf("Input");

// Processed Level Meter (Green)
proc_meter_x = meter_x + 40;
gfx_r = 0; gfx_g = 1; gfx_b = 0;
gfx_rect(proc_meter_x, meter_y, meter_width, meter_height, 0); // Frame

// Fill based on level
processed_fill_height = ((processed_level_db + 60) / 60) * meter_height;
processed_fill_height = max(0, min(meter_height, processed_fill_height));
gfx_r = 0; gfx_g = 1; gfx_b = 0;
gfx_rect(proc_meter_x + 1, meter_y + meter_height - processed_fill_height, meter_width - 2, processed_fill_height);

// Label
gfx_x = proc_meter_x - 15; gfx_y = meter_y + meter_height + 10;
gfx_printf("Processed");

// Target Range markers on both meters
target_min_pos = meter_y + meter_height - ((target_range_min + 60) / 60) * meter_height;
target_max_pos = meter_y + meter_height - ((target_range_max + 60) / 60) * meter_height;
target_min_pos = max(meter_y, min(meter_y + meter_height, target_min_pos));
target_max_pos = max(meter_y, min(meter_y + meter_height, target_max_pos));

// Target range markers (Yellow)
gfx_r = 1; gfx_g = 1; gfx_b = 0;
gfx_line(meter_x - 5, target_min_pos, meter_x + meter_width + 5, target_min_pos);
gfx_line(meter_x - 5, target_max_pos, meter_x + meter_width + 5, target_max_pos);
gfx_line(proc_meter_x - 5, target_min_pos, proc_meter_x + meter_width + 5, target_min_pos);
gfx_line(proc_meter_x - 5, target_max_pos, proc_meter_x + meter_width + 5, target_max_pos);

// Target center line (Red)
target_center_pos = meter_y + meter_height - ((target_center + 60) / 60) * meter_height;
target_center_pos = max(meter_y, min(meter_y + meter_height, target_center_pos));
gfx_r = 1; gfx_g = 0; gfx_b = 0;
gfx_line(meter_x - 5, target_center_pos, proc_meter_x + meter_width + 5, target_center_pos);

// dB Scale
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
db_marks = (-60, -40, -20, -10, -6, -3, 0);
i = 0;
loop(7,
  db_val = db_marks[i];
  scale_pos = meter_y + meter_height - ((db_val + 60) / 60) * meter_height;
  scale_pos = max(meter_y, min(meter_y + meter_height, scale_pos));
  gfx_line(meter_x - 15, scale_pos, meter_x - 5, scale_pos);
  gfx_x = meter_x - 35; gfx_y = scale_pos - 5;
  gfx_printf("%.0f", db_val);
  i += 1;
);

// Numerical readouts
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 430;
gfx_printf("Input Level: %.1f dB", input_level_db);

gfx_x = 10; gfx_y = 450;
gfx_printf("Processed Level: %.1f dB", processed_level_db);