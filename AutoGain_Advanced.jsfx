// AutoGain Advanced JSFX Plugin
// Автоматическая регулировка громкости с анализом LUFS и лимитером
// Автор: AI Assistant
// Версия: 1.0

desc:AutoGain Advanced - LUFS Analysis & Limiter

// Параметры плагина
slider1:0<0,1,0.001>Bypass (0=Off, 1=On)
slider2:-30<-60,0,0.1>Target Min (dB)
slider3:-10<-30,0,0.1>Target Max (dB)
slider4:0.1<0.01,1,0.01>Moving Average Smoothing
slider5:-1<-1,1,0.1>Input Gain (dB)
slider6:-0.1<-20,0,0.1>Output Gain (dB)
slider7:0<0,1,0.001>Limiter Enable
slider8:-0.1<-20,0,0.1>Limiter Threshold (dB)
slider9:0<0,1,0.001>True Peak Mode
slider10:0.1<0.01,1,0.01>Limiter Release (s)
slider11:0<0,1,0.001>LUFS Display Mode (0=Peak, 1=RMS, 2=LUFS-S, 3=LUFS-M)

// Внутренние переменные
@init
// Буферы для анализа
peak_buffer_size = 2048;
rms_buffer_size = 2048;
lufs_buffer_size = 48000; // 1 секунда при 48kHz

peak_buffer = 0;
rms_buffer = 0;
lufs_buffer = 0;

// Индексы буферов
peak_idx = 0;
rms_idx = 0;
lufs_idx = 0;

// Текущие значения
current_peak = 0;
current_rms = 0;
current_lufs_s = 0;
current_lufs_m = 0;

// Скользящие средние
moving_avg_peak = 0;
moving_avg_rms = 0;
moving_avg_lufs_s = 0;
moving_avg_lufs_m = 0;

// Коэффициенты сглаживания
smoothing_factor = 0.1;

// Переменные лимитера
limiter_gain = 1;
limiter_peak = 0;
true_peak_left = 0;
true_peak_right = 0;

// Счетчики для LUFS
lufs_sample_count = 0;
lufs_sum = 0;

// Инициализация буферов
peak_buffer = 0;
rms_buffer = 0;
lufs_buffer = 0;

// Функция для вычисления LUFS
function lufs_calculate(input)
(
  // Простая реализация LUFS (упрощенная версия)
  // В реальности LUFS использует сложные фильтры и взвешивание
  lufs_value = 20 * log10(abs(input));
  lufs_value;
);

// Функция для обновления скользящего среднего
function update_moving_average(current_value, old_avg)
(
  new_avg = old_avg * (1 - smoothing_factor) + current_value * smoothing_factor;
  new_avg;
);

// Функция для вычисления RMS
function rms_calculate(input)
(
  rms_value = sqrt(input * input);
  rms_value;
);

// Функция для обновления буферов
function update_buffers(input)
(
  // Обновление peak buffer
  peak_buffer[peak_idx] = abs(input);
  peak_idx = (peak_idx + 1) % peak_buffer_size;
  
  // Обновление RMS buffer
  rms_buffer[rms_idx] = input * input;
  rms_idx = (rms_idx + 1) % rms_buffer_size;
  
  // Обновление LUFS buffer
  lufs_buffer[lufs_idx] = input;
  lufs_idx = (lufs_idx + 1) % lufs_buffer_size;
);

// Функция для вычисления средних значений из буферов
function calculate_averages()
(
  // Peak average
  peak_sum = 0;
  i = 0;
  while (i < peak_buffer_size)
  (
    peak_sum += peak_buffer[i];
    i += 1;
  );
  current_peak = peak_sum / peak_buffer_size;
  
  // RMS average
  rms_sum = 0;
  i = 0;
  while (i < rms_buffer_size)
  (
    rms_sum += rms_buffer[i];
    i += 1;
  );
  current_rms = sqrt(rms_sum / rms_buffer_size);
  
  // LUFS average (упрощенная версия)
  lufs_sum = 0;
  i = 0;
  while (i < lufs_buffer_size)
  (
    lufs_sum += abs(lufs_buffer[i]);
    i += 1;
  );
  current_lufs_s = 20 * log10(lufs_sum / lufs_buffer_size);
  current_lufs_m = current_lufs_s; // Упрощенная версия LUFS-M
);

// Функция для вычисления коэффициента усиления
function calculate_gain()
(
  // Выбор метрики в зависимости от режима отображения
  metric_value = 0;
  if (slider11 == 0) metric_value = 20 * log10(current_peak);
  else if (slider11 == 1) metric_value = 20 * log10(current_rms);
  else if (slider11 == 2) metric_value = current_lufs_s;
  else metric_value = current_lufs_m;
  
  // Обновление скользящего среднего
  if (slider11 == 0) moving_avg_peak = update_moving_average(metric_value, moving_avg_peak);
  else if (slider11 == 1) moving_avg_rms = update_moving_average(metric_value, moving_avg_rms);
  else if (slider11 == 2) moving_avg_lufs_s = update_moving_average(metric_value, moving_avg_lufs_s);
  else moving_avg_lufs_m = update_moving_average(metric_value, moving_avg_lufs_m);
  
  // Выбор текущего скользящего среднего
  current_moving_avg = 0;
  if (slider11 == 0) current_moving_avg = moving_avg_peak;
  else if (slider11 == 1) current_moving_avg = moving_avg_rms;
  else if (slider11 == 2) current_moving_avg = moving_avg_lufs_s;
  else current_moving_avg = moving_avg_lufs_m;
  
  // Вычисление целевой громкости
  target_level = (slider2 + slider3) / 2;
  target_range = slider3 - slider2;
  
  // Вычисление коэффициента усиления
  gain_db = target_level - current_moving_avg;
  
  // Ограничение усиления в пределах целевого диапазона
  if (gain_db > target_range / 2) gain_db = target_range / 2;
  if (gain_db < -target_range / 2) gain_db = -target_range / 2;
  
  // Преобразование в линейный коэффициент
  gain_linear = 10^(gain_db / 20);
  
  gain_linear;
);

// Функция для лимитера
function limiter_process(input, channel)
(
  // True Peak detection (oversampling)
  if (slider9 > 0.5)
  (
    // Простая реализация True Peak (упрощенная)
    if (channel == 0)
    (
      true_peak_left = max(true_peak_left, abs(input));
    )
    else
    (
      true_peak_right = max(true_peak_right, abs(input));
    );
    
    peak_value = max(true_peak_left, true_peak_right);
  )
  else
  (
    peak_value = abs(input);
  );
  
  // Вычисление коэффициента лимитера
  if (peak_value > 10^(slider8 / 20))
  (
    limiter_gain = 10^(slider8 / 20) / peak_value;
  )
  else
  (
    limiter_gain = 1;
  );
  
  // Применение release
  limiter_gain = limiter_gain * (1 - slider10) + 1 * slider10;
  
  // Ограничение минимального значения
  if (limiter_gain < 0.001) limiter_gain = 0.001;
  
  input * limiter_gain;
);

@slider
// Обновление коэффициента сглаживания
smoothing_factor = slider4;

@sample
// Основная обработка
spl0 = spl0 * 10^(slider5 / 20); // Input Gain
spl1 = spl1 * 10^(slider5 / 20);

// Обновление буферов анализа
update_buffers(spl0);
update_buffers(spl1);

// Вычисление средних значений каждые 64 сэмпла
lufs_sample_count += 1;
if (lufs_sample_count >= 64)
(
  calculate_averages();
  lufs_sample_count = 0;
);

// Вычисление коэффициента усиления AutoGain
if (slider1 > 0.5)
(
  gain_coeff = calculate_gain();
  spl0 = spl0 * gain_coeff;
  spl1 = spl1 * gain_coeff;
);

// Применение лимитера
if (slider7 > 0.5)
(
  spl0 = limiter_process(spl0, 0);
  spl1 = limiter_process(spl1, 1);
);

// Output Gain
spl0 = spl0 * 10^(slider6 / 20);
spl1 = spl1 * 10^(slider6 / 20);

// Сброс True Peak каждые 1000 сэмплов
if (lufs_sample_count == 0)
(
  true_peak_left = 0;
  true_peak_right = 0;
);

@gfx 400 300
// Визуализация
gfx_set(0.2, 0.2, 0.2, 1);
gfx_fillrect(0, 0, gfx_w, gfx_h);

// Отображение текущих значений
gfx_set(1, 1, 1, 1);
gfx_x = 10;
gfx_y = 20;
gfx_drawstr("AutoGain Advanced v1.0");

gfx_x = 10;
gfx_y = 40;
gfx_drawstr("Peak: " + sprintf("%.1f", 20 * log10(current_peak)) + " dB");

gfx_x = 10;
gfx_y = 60;
gfx_drawstr("RMS: " + sprintf("%.1f", 20 * log10(current_rms)) + " dB");

gfx_x = 10;
gfx_y = 80;
gfx_drawstr("LUFS-S: " + sprintf("%.1f", current_lufs_s) + " LUFS");

gfx_x = 10;
gfx_y = 100;
gfx_drawstr("LUFS-M: " + sprintf("%.1f", current_lufs_m) + " LUFS");

// Отображение скользящего среднего
gfx_x = 10;
gfx_y = 130;
current_moving_avg = 0;
if (slider11 == 0) current_moving_avg = moving_avg_peak;
else if (slider11 == 1) current_moving_avg = moving_avg_rms;
else if (slider11 == 2) current_moving_avg = moving_avg_lufs_s;
else current_moving_avg = moving_avg_lufs_m;

gfx_drawstr("Moving Avg: " + sprintf("%.1f", current_moving_avg) + " dB");

// Отображение целевого диапазона
gfx_x = 10;
gfx_y = 160;
gfx_drawstr("Target: " + sprintf("%.1f", slider2) + " to " + sprintf("%.1f", slider3) + " dB");

// Отображение коэффициента усиления
gfx_x = 10;
gfx_y = 190;
gain_db = 20 * log10(calculate_gain());
gfx_drawstr("Gain: " + sprintf("%.1f", gain_db) + " dB");

// Отображение статуса лимитера
gfx_x = 10;
gfx_y = 220;
if (slider7 > 0.5)
(
  gfx_set(1, 0.5, 0, 1);
  gfx_drawstr("Limiter: ON");
)
else
(
  gfx_set(0.5, 0.5, 0.5, 1);
  gfx_drawstr("Limiter: OFF");
);

// Отображение True Peak
gfx_x = 10;
gfx_y = 250;
if (slider9 > 0.5)
(
  true_peak_db = 20 * log10(max(true_peak_left, true_peak_right));
  gfx_set(1, 0, 0, 1);
  gfx_drawstr("True Peak: " + sprintf("%.1f", true_peak_db) + " dB");
)
else
(
  gfx_set(0.5, 0.5, 0.5, 1);
  gfx_drawstr("True Peak: OFF");
);

// График уровня
gfx_x = 200;
gfx_y = 20;
gfx_set(0.3, 0.3, 0.3, 1);
gfx_fillrect(gfx_x, gfx_y, 180, 100);

// Отрисовка целевого диапазона
gfx_set(0, 1, 0, 0.3);
target_y1 = gfx_y + 100 - (slider2 + 60) * 2;
target_y2 = gfx_y + 100 - (slider3 + 60) * 2;
gfx_fillrect(gfx_x, target_y2, 180, target_y1 - target_y2);

// Отрисовка текущего уровня
gfx_set(1, 1, 0, 1);
current_level = current_moving_avg;
if (current_level < -60) current_level = -60;
if (current_level > 0) current_level = 0;
level_y = gfx_y + 100 - (current_level + 60) * 2;
gfx_fillrect(gfx_x, level_y - 2, 180, 4);

// Подписи осей
gfx_set(1, 1, 1, 1);
gfx_x = 200;
gfx_y = 130;
gfx_drawstr("Level (dB)");
gfx_x = 200;
gfx_y = 145;
gfx_drawstr("-60     -30      0");